Назначение:

Библиотека FastFish предназначена для организации полнотекстового поиска в приложении. 
На данный момент API представлен на языке C++, в дальнейшем планируется добавление 
оберток для использования на других языках.

Ключевые особенности:

Поисковые запросы используют Standard Boolean model. Это позволяет получить высокую 
скорость выполнения запросов. Например, для простых конъюнктивных запросов и размере 
индекса порядка единиц гигабайт, возможно выполнение нескольких десятков тысяч 
запросов в секунду на одно процессорное ядро.

Поддерживается статическое ранжирование документов, т.е. ранг документа задается 
при построении индекса.

Высокая скорость построения индекса - несколько десятков мегабайт в секунду 
на одно ядро.

Поиск возможен по индексу, состоящему из нескольких сегментов. При большом количестве 
сегментов, скорость выполнения запросов снижается незначительно. Например, при размере 
индекса около гигабайта, разбиение его на 50 сегментов замедляет скорость выполнения 
простых конъюнктивных запросов примерно в 2 раза. 

Каждый сегмент индекса самодостаточен, возможно произвольное комбинирование сегментов, 
если они имеют одинаковый тип.

Загрузка сегментов является легковесной операцией, чтение всего файла при этом 
не требуется. Данные сегмента используются при поиске посредством memory mapping. 
Это накладывает ограничение на суммарный объем индекса при поиске на 32-битной платформе 
(зависит от OS, обычно 2GB).

FastFish ориентированна на задачи, в которых индекс целиком помещается в оперативную 
память или незначительно превышает ее объем, не более чем в несколько раз. При поиске 
по индексу, не помещающемуся в память и хранящемуся на HDD, скорость существенно падает. 
При использовании SSD падение невелико. 

Запрос состоит из элементарных операций, которые могут быть скомбинированы логическими 
операторами и сгруппированы с произвольной степенью вложенности.

FastFish работает с текстом в формате UTF-8. Внутренние данные хранятся непосредственно 
в этом представлении. Поддерживается полный набор символов Unicode, т.е. в том числе 
символы выше U+FFFF. Поддерживается case-insensitive поиск.

Системные требования:
	Аппаратная платформа: 32 или 64-битные машины, как little-endian, так и big-endian. 
		Возможно использование платформы с строгими требованиями к data alignment.
	OS: POSIX-совместимая среда либо Win32/64.
	Компилятор: на текущий момент собираемость и работоспособность была протестирована 
		на GCC 4.3.4 и 4.5.0, MSVC 2005, ICC 11.1/Windows.

	Формат индекса зависит только от endianness платформы. Т.е. индекс, созданный 
	на little-endian платформе, будет непригоден для поиска на big-endian платформе 
	и наоборот. Все остальные характеристики (разрядность, OS, компилятор) 
	не влияют на бинарный формат индекса.

Ограничения:
	* 2 147 483 647 документов на один сегмент
	* 65 536 сегментов 
	* 128 полей в индексе
	* 255 элементарных операций в запросе
	* 32 слова на каждую элементарную операцию
	* 65 535 рангов
	* 65 536 - длинна значения в поле данных 
	* 65 536 - длинна слова в текстах для поискового поля
	Длинна текста в одном поисковом поле одного документа не ограниченна.

//////////////////////////////////////////////////////////////////////////////	
Краткое описание
//////////////////////////////////////////////////////////////////////////////	

Структура индекса

Индекс состоит из множества полей (field) и множества документов (document). 
Тип индекса определяется множеством полей. Файлы индексов одинакового типа могут 
рассматриваться как сегменты одного индекса. Порядок следования сегментов задается 
порядком загрузки файлов в объект Searcher.

Поля делятся на 2 категории - поисковые (search field) и поля данных (data field). 
Только search field могут использоваться для поиска документов. Данные, передаваемые 
в search field при построении индекса, в своем исходном виде в индексе не сохраняются. 
Для получения данных документа при поиске служат data field.

Search Field:

На текущий момент search field имеет только один возможный тип - текст. Текст поля 
состоит из множества слов. Разбиение текста на слова производится библиотекой 
на основе списка возможных разделителей слов. Список разделителей является одним 
из атрибутов типа поля. 

Текстовое поле может быть 3-х основных подтипов (enum TextIndexType):
	* Exact - поиск слова, точно соответствующему заданному. Например, если документ 
		содержит слово "abracadabra", то он будет найден при указании в запросе 
		этого слова целиком. Индекс с таким полем будет занимать меньше 
		всего места и быстрее всего строиться.
	* Prefix - поиск по префиксу слова. Например, документ с "abracadabra" может 
		быть найден не только по полному слову, но и по "abracadab" или "abraca" 
		и т.п. Построение такого индекса занимает немного больше времени 
		(обычно на 10-20%), но размер индекса существенно возрастает.
	* Infix - поиск по любой подстроке слова. Например, "abracadabra" будет найдена 
		по "brac", "cada", "cadabra" и т.п. Время построения индекса существенно 
		(обычно в 2-3 раза) возрастает по сравнению с Prefix, размер индекса тоже.

Data Field:

В текущей версии поддерживаются 2 типа полей данных - с постоянной длинной данных 
(шаблон TplFieldDataFix) и с переменной (шаблон TplFieldDataVar). FieldDataFix может 
использоваться, например, для хранения какого-либо числа, связанного с документом. 
FieldDataVar подходит для хранения любых данных нерегулярной длинны, например, 
текста заголовка документа.

Запросы

В запросах FastFish искомые данные отделены от текста запроса и передаются в виде 
аргументов в объект запроса (Query). Запрос представляет собой текстовое выражение, 
оперирующее индексами полей и индексами аргументов.

При поиске по текстовому полю аргумент представляет собой строку из слов. 
Для разделения слов могут применяться те же символы, что и при построении индекса 
(для соответствующего поля).

Для текстового поля возможны 2 типа элементарных операций в запросах:
	* документы, включающий в себя все слова аргумента 
		- обозначается буквой a (от all)
	* документы, включающий в себя какое-либо слово аргумента 
		- обозначается буквой s (от some)

Формат элементарной операции - %OP%%FIELD%.%ARG % , где: 
	* %OP% - код операции, "а" или "s"
	* %FIELD% - индекс поля, по которому искать
	* %ARG% - индекс аргумента
	
Пример запроса: "a3,0" - выборка из документов, в 3-м поле включающих все слова, 
указанные в аргументе 0.

Элементарные операции можно комбинировать с помощью "&" (конъюнкция, бинарный оператор), 
"|" (дизъюнкция, бинарный оператор), "!" (отрицание, унарный оператор) и группировать 
с помощью скобок. При отсутствии скобок операторы имеют приоритет 
(в порядке убывания): ! & | .

Пример запроса: "!(a3,0 | s2,1)" - все документы, не входящие в следующее множество: 
все документы, содержащие все слова аргумента 0 в поле 3 или 
содержащие какое-либо слово из аргумента 1 в поле 2. 

Количество уровней вложенности скобок не ограниченно, ограниченно только количество 
элементарных операций (255 штук).

Запрос выполняется при передаче объекту Query аргументов. Результатом является 
последовательность документов (Sequence). Для положения в Sequence ранг имеет 
наибольший приоритет, затем сегмент, затем номер документа в сегменте. 
Сегмент и номер учитываются в обратном порядке, т.е. последний добавленный документ 
последнего сегмента находится в Sequence первым среди документов своего ранга.

Вычисление следующего документа в Sequence происходит только при вызове 
Sequence::Next(). Точная длинна Sequence может быть выяснена только путем выборки 
из нее всех документов. Приблизительную длину можно оценить по атрибуту 
Sequence::ApproximateLength. Если запрос включает в себя множество слов, то оценка 
может существенно отличаться от точной длинны. В частных случаях, когда весь запрос 
сводится к поиску по 1 слову, ApproximateLength выдает результат, совпадающий 
с точной длинной последовательности.

Обработка ошибок	

Ошибки можно разделить на 2 категории: времени выполнения и времени разработки. 
К ошибкам времени выполнения можно отнести ошибки ввода-вывода, некорректные 
входные данные или нехватку ресурсов. К ошибкам времени разработки относятся 
логические ошибки в коде самой библиотеки или некорректное ее использование. 

Ошибки времени выполнения:

Для сообщения вызывающей стороне о ошибках времени выполнения библиотека FastFish 
использует механизм C++ исключений. Все методы и функции имеют спецификацию 
генерируемых исключений одного из 2-х типов:
	* throw() - метод не генерирует исключений
	* ffThrowAll - метод генерирует какие-либо исключения, унаследованные 
		из std::runtime_error (классы Except* из Сommon/Types.h)

Особый случай представляет собой обработка нехватки памяти. Библиотека сознательно 
игнорирует возникновение bad_alloc - методы, в которых может возникнуть это исключение, 
имеют спецификацию throw(). Поддерживаются только слабые гарантии на обработку bad_alloc, 
т.е. ресурсы, занятые объектами FastFish, будут освобождены при удалении объектов. 
Но после возникновения bad_alloc объект может остаться в некорректном состоянии. 

Такой подход применяется для достижения высокой производительности, т.к. поддержание 
корректного состояния объектов после bad_alloc привело бы к накладным расходам, 
в том числе и при нормальном исполнении.

Если вызывающей стороне необходимо разбивать индекс на сегменты при нехватке памяти, 
то это возможно реализовать вызовом std::set_new_handler и установкой обработчика. 
Перед началом построения индекса необходимо зарезервировать блок памяти, достаточный 
для завершения построения части сегмента. При вызове обработчика блок освобождается, 
текущие данные сохраняются в виде сегмента, опять резервируется "аварийный" блок 
и процесс построения продолжается далее. 

Пример такой обработки нехватки памяти можно увидеть в демонстрационных приложениях 
GeoImport и WikiImport - при указании параметра "-sm" индекс разбивается на сегменты 
автоматически (если память заканчивается).

Передача в FastFish некорректных UTF-8 последовательностей не считается критической 
ошибкой. Библиотека всегда проверяет валидность UTF-8 после разбиения текста на слова 
(как при построении индекса, так и при поиске). Если находятся некорректные 
последовательности - слово обрезается до последнего корректного символа, 
исключение при этом не генерируется. Возможен вывод предупреждений в лог 
в случае возникновения таких ситуаций.

Ошибки времени разработки (bugs):

Библиотека может быть собрана в двух возможных конфигурациях, release или debug. 
Поведение FastFish в этих конфигурациях различается.

В debug конфигурации во время выполнения проверяется возможность возникновения 
логических ошибок с помощью утверждений (asserts). Если какое-либо утверждение 
не выполняется, происходит останов программы и вызов отладчика. Для ошибок, 
которые являются следствием некорректного использования FastFish, в лог выводятся 
записи типа lsBugUser, подсказывающие, что код вызывающей стороны делает не так. 
Наличие проверки утверждений является одной из причин того, что debug версия работает 
существенно медленнее release версии.

В release утверждения не проверяются, предполагается, что все они верны. В случае 
нарушения любого утверждения, поведение FastFish не определено.

Следует заметить, что, при поиске к bugs относятся также некорректные данные в индексе. 
Т.е. предполагается, что некорректный индекс является следствием логической ошибки 
в коде построения индекса. Ситуации, когда файл индекса после построения был изменен 
из за сторонних факторов, не рассматриваются, т.к. полная проверка корректности индекса 
является ресурсоемкой задачей. В release версии во время выполнения проверяется 
только сигнатура файла.

Логгирование:

Информация о ошибках, предупреждениях и некоторые справочные данные, могут выводиться 
библиотекой в лог в текстовой форме. По умолчанию логом является поток stderr, 
но для любого типа записей лога (независимо) он может быть заменен на любой другой 
объект типа FILE*. 

Записи в логе делятся на несколько типов, все они перечислены в enum LogStream (Common/Log.h).

Логгирование записей любого типа может быть отключено, как на стадии компиляции 
(удалением типа из константы LogStream::lsAll), так и во время выполнения (путем 
указания (FILE*)0 в SetLog). Для записей типа LogStream::lsBug тип конфигурации 
release/debug является более приоритетным, чем управление логгированием, т.е. 
в release конфигурации этот тип записей не выводится в любом случае.

//////////////////////////////////////////////////////////////////////////////

Лицензия

FastFish распространяется на условиях лицензии General Public License version 2. 
Текст лицензии можно найти в файле license.txt, поставляемом с библиотекой, 
или на сайте www.gnu.org .

Приоритеты разработки:
	0. Отсутствие багов. Те функции, которые реализованы, должны работать правильно.
	1. Скорость выполнения запросов.
	2. Скорость построения индекса.
	3. Минимизация размера индекса.
	Пункты 1 и 2 как правило не вступают в противоречие.
	
Политика изменения версий FastFish:
Номер версии выглядит как major.minor.revision .
	* Инкремент revision не влияет на формат индекса и на API. Новый revision 
		могут получить версии с улучшенной производительностью 
		или исправленными ошибками.
	* Инкремент minor может влиять на формат индекса, но старые файлы индекса 
		должны оставаться совместимыми с кодом, собранным с новой версией 
		FastFish. Новые файлы индекса могут быть несовместимы с кодом, 
		собранным со старой версией FastFish. Возможны дополнения в API 
		с сохранением обратной совместимости, т.е., для перекомпиляции 
		с новой версией, код, использующий FastFish, изменять не требуется. 
	* Инкремент major означает полную потерю совместимости со старыми файлами 
		индекса и/или существенные изменения в API, т.е. для сборки с новой 
		версией вызывающий код может потребовать изменений.

Версия данного документа - 0.0.0

История версий
	0.0.0 - начальный выпуск
	0.0.0 - существенно (примерно в 2.5 раза) снижено потребление памяти при 
			построении индекса
